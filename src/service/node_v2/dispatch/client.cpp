#include "cocaine/detail/service/node_v2/dispatch/client.hpp"

#include "cocaine/detail/service/node_v2/slave.hpp"

using namespace cocaine;

enqueue_dispatch_t::enqueue_dispatch_t(const std::string& name):
    dispatch<incoming_tag>(format("%s/C2W", name)),
    state(state_t::open)
{
    on<protocol::chunk>([&](const std::string& chunk) {
        stream.write(chunk);
    });

    on<protocol::error>([&](int id, const std::string& reason) {
        stream.abort(id, reason);
        finalize();
    });

    on<protocol::choke>([&] {
        stream.close();
        finalize();
    });
}

void
enqueue_dispatch_t::attach(upstream<outcoming_tag> stream,
                           std::uint64_t id,
                           std::shared_ptr<state_machine_t> slave)
{
    this->stream.attach(std::move(stream));

    std::lock_guard<std::mutex> lock(mutex);

    this->id.reset(id);
    this->slave = std::move(slave);

    if (state == state_t::closed) {
        this->slave->on_tx_channel_close(id);
    }
}

void
enqueue_dispatch_t::discard(const std::error_code& ec) const {
    const_cast<enqueue_dispatch_t*>(this)->discard(ec);
}

void
enqueue_dispatch_t::discard(const std::error_code& ec) {
    if (ec) {
        // TODO: Add category to indicate that the error is generated by the core.
        stream.abort(1, ec.message());
        finalize();
    }
}

void
enqueue_dispatch_t::finalize() {
    std::lock_guard<std::mutex> lock(mutex);

    BOOST_ASSERT(state == state_t::open);

    state = state_t::closed;
    if (slave) {
        slave->on_tx_channel_close(*id);
    }
}
